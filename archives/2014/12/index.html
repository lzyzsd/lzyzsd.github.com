<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Archives: 2014/12 | Bruce Lee&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Bruce Lee's Blog">
<meta property="og:url" content="http://blog.jinkuyinku.com/archives/2014/12/">
<meta property="og:site_name" content="Bruce Lee's Blog">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Bruce Lee's Blog">
<meta name="twitter:description">

  
    <link rel="alternative" href="/atom.xml" title="Bruce Lee&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">

  
</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Bruce Lee&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><input type="submit" value="&#xF002;" class="search-form-submit"><input type="hidden" name="q" value="site:http://blog.jinkuyinku.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="square-android-gradle-深入浅出（二:项目结构）" class="article article-type-square" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/12/27/android-gradle-深入浅出（二:项目结构）/" class="article-date">
  <time datetime="2014-12-27T10:29:50.000Z" itemprop="datePublished">Dec 27 2014</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/12/27/android-gradle-深入浅出（二:项目结构）/">android-gradle-深入浅出（二:项目结构）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>Android</li>
<li>Gradle</li>
<li>Android Studio</li>
</ul>
<p>这篇主要介绍使用Gradle的Android项目的目录结构，以及在Gradle中的配置</p>
<p>Gradle采用约定优于配置的原则，最简单方式是使用一个默认的目录结构。当然目录结构是可以自己修改的。</p>
<p>默认情况下，android gradle项目的代码都在src目录下，src下会有两个目录main和androidTest，其中main目录下是项目代码，androidTest目录下是测试代码。<br>src/main/<br>src/androidTest/</p>
<p>在main和androidTest目录下面，针对不同类型的code，又不会不同的目录。<br>对于Java和Android的Gradle插件，Java代码和Java资源分别对应了java目录和resources目录。Android插件还需要一些其他的目录和文件，比如<br>AndroidManifest.xml<br>res/<br>assets/<br>aidl/<br>rs/<br>jni/</p>
<p>下面我们来看一下如何更改这些默认的配置。</p>
<p>Android工程，默认情况下，java文件和resource文件分别在src/main/java和src/main/res目录下，在build.gradle文件，andorid{}里面添加下面的代码，便可以将java文件和resource文件放到src/java和src/resources目录下。（注意，如果你在gradle文件中修改了，只需要重新sync一下，gradle会自动创建新的目录，并将对应的文件移动到新的目录下）</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="title">sourceSets</span> {</div><div class="line">    <span class="title">main</span> {</div><div class="line">        <span class="title">java</span> {</div><div class="line">            <span class="title">srcDir</span> <span class="string">'src/java'</span></div><div class="line">        }</div><div class="line">        resources {</div><div class="line">            <span class="title">srcDir</span> <span class="string">'src/resources'</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>更简便的写法是</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">source</span>Sets {</div><div class="line">    main.java.srcDirs = [<span class="string">'src/java'</span>]</div><div class="line">    main.resources.srcDirs = [<span class="string">'src/resources'</span>]</div><div class="line">}</div></pre></td></tr></table></figure>

<p>数组里其实是可以指定多个目录，这样就可以将代码和资源放置到多个目录下。<br>在看一个Android项目的例子：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">android {</div><div class="line">    <span class="built_in">source</span>Sets {</div><div class="line">        main {</div><div class="line">            manifest.srcFile <span class="string">'AndroidManifest.xml'</span></div><div class="line">            java.srcDirs = [<span class="string">'src'</span>]</div><div class="line">            resources.srcDirs = [<span class="string">'src'</span>]</div><div class="line">            aidl.srcDirs = [<span class="string">'src'</span>]</div><div class="line">            renderscript.srcDirs = [<span class="string">'src'</span>]</div><div class="line">            res.srcDirs = [<span class="string">'res'</span>]</div><div class="line">            assets.srcDirs = [<span class="string">'assets'</span>]</div><div class="line">        }</div><div class="line"></div><div class="line">        androidTest.setRoot(<span class="string">'tests'</span>)</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里的main code其实使用的就是Android Gradle的默认值，而androidTest不再使用默认的androidTest目录，而是使用tests目录。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.jinkuyinku.com/2014/12/27/android-gradle-深入浅出（二:项目结构）/" data-id="l34l1c00a588olhv" class="article-share-link">Share</a>
      
        <a href="http://blog.jinkuyinku.com/2014/12/27/android-gradle-深入浅出（二:项目结构）/#disqus_thread" class="article-comment-link">Comments</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="square-android-gradle-深入浅出（一:简介）" class="article article-type-square" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/12/23/android-gradle-深入浅出（一:简介）/" class="article-date">
  <time datetime="2014-12-23T14:45:36.000Z" itemprop="datePublished">Dec 23 2014</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/12/23/android-gradle-深入浅出（一:简介）/">android-gradle-深入浅出（一）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>Android</li>
<li>Gradle</li>
<li>Android Studio</li>
</ul>
<p>gradle是Android开发中引入的全新的构建系统，因为全新的构建系统主要是出于下面的目的：</p>
<ol>
<li>方便复用代码和资源</li>
<li>构建多种版本的apk更见简单，不论是为多渠道构建不同的apk还是构建不同环境的apk（debug，release）</li>
<li>方便配置，扩展，自定义构建过程</li>
<li>良好的IDE集成</li>
</ol>
<h2 id="为什么选择Gradle？">为什么选择Gradle？</h2>
<p>Gradle主要有以下几个有点：</p>
<ol>
<li>使用领域驱动语言（DSL）来描述构建逻辑</li>
<li>构建脚本使用Groovy，可以方便的定制构建逻辑</li>
<li>内建的依赖管理系统，使用Maven或者Ivy</li>
<li>非常灵活。可以使用最佳实践但并不强制</li>
<li>良好的IDE支持</li>
</ol>
<p>Gradle项目使用项目根目录下的build.gradle文件来配置</p>
<p>一个最简单的Java项目的build.gradle如下</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">apply</span> plugin: <span class="string">'java'</span></div></pre></td></tr></table></figure>

<p>这表示改项目会使用Gradle的java插件，该插件是Gradle默认提供的，java插件提供了构建java应用和运行测试的功能。</p>
<p>最简单的Android项目build.gralde如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">buildscript</span> {</div><div class="line">    <span class="keyword">repositories</span> {</div><div class="line">        mavenCentral()</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">dependencies</span> {</div><div class="line">        <span class="keyword">classpath</span> <span class="string">'com.android.tools.build:gradle:0.11.1'</span></div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line">apply plugin: <span class="string">'android'</span></div><div class="line"></div><div class="line">android {</div><div class="line">    compileSdkVersion <span class="number">19</span></div><div class="line">    buildToolsVersion <span class="string">"19.0.0"</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>该Android构建文件包含3个部分：<br>buildscript { … } 配置驱动构建过程的代码，意思就是buildscript中的配置仅仅在构建过程中起作用，也就是构建程序所使用的配置。<br>上面的代码中就声明了我们的构建程序会使用Maven中央仓库，并且有一个classpath依赖是指向一个Maven库的。这个Maven库就是Android Gradle插件，版本号是0.11.1。</p>
<p>随后就是使用这个Android插件，和之前使用Java插件一样。</p>
<p>最后，android { … }配置了Android项目构建时需要的所有参数。<br>默认情况下，只需要指定compileSdkVersion和buildtoolsVersion，compileSdkVersion指定使用哪个版本的sdk编译，buildToolsVersion指定使用哪个版本的构建工具。</p>
<h2 id="小心:">小心:</h2>
<ol>
<li>只需要使用android插件，再使用Java插件会报错.</li>
<li>在local.properties中使用sdk.dir属性指定SDK路径，或者你可以使用ANDROID_HOME环境变量。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.jinkuyinku.com/2014/12/23/android-gradle-深入浅出（一:简介）/" data-id="dx3diib12nwe1gar" class="article-share-link">Share</a>
      
        <a href="http://blog.jinkuyinku.com/2014/12/23/android-gradle-深入浅出（一:简介）/#disqus_thread" class="article-comment-link">Comments</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="square-Otto源码分析" class="article article-type-square" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/12/18/Otto源码分析/" class="article-date">
  <time datetime="2014-12-18T14:27:04.000Z" itemprop="datePublished">Dec 18 2014</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/12/18/Otto源码分析/">Otto源码分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>android</li>
<li>square</li>
<li>Otto</li>
<li>event bus</li>
<li>源码分析</li>
</ul>
<h2 id="构造函数">构造函数</h2>
<p>使用Otto通常是通过一个Provider提供一个Bus单例。<br>首先我们来分析一下Bus的构造函数，Bus类的构造函数最终都会调用Bus(ThreadEnforcer enforcer, String identifier, HandlerFinder handlerFinder)这个构造函数。<br>其中enforcer用来限制执行register，unregister以及post event的线程，如果执行这些函数的线程不是enforcer指定的线程，就会抛出异常。<br>identifier相当于给Bus起的一个名字，在toString方法中使用。<br>handlerFinder是整个event bus的核心，用于在register，unregister的时候寻找所有的subscriber和producer。handlerFinder不需要用户指定，默认使用HandlerFinder接口中定义的常量ANNOTATED，ANNOTATED本身就是HandlerFinder的匿名实现。</p>
<h2 id="注册">注册</h2>
<p>如果一个类对某些事件感兴趣，需要调用register方法来注册监听这些事件，监听通过在方法上使用@Subscribe来实现，Otto通过方法的参数来决定是否调用该方法。<br>register方法首先会调用handlerFinder的findAllProducers（object）方法去找到所有使用了@Produce注解的方法。findAllProducers其实是委托AnnotatedHandlerFinder.findAllProducers方法。在AnnotatedHandlerFinder中，定义了一个静态变量SUBSCRIBERS_CACHE</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Map&lt;Class&lt;?&gt;, Method&gt;&gt; PRODUCERS_CACHE =</div><div class="line">      <span class="keyword">new</span> HashMap&lt;Class&lt;?&gt;, Map&lt;Class&lt;?&gt;, Method&gt;&gt;();</div></pre></td></tr></table></figure>

<p>PRODUCERS_CACHE 的key是监听类，就是调用bus.register()的类，value本身又是一个map，这个map的key是事件的class，value是生产事件的方法。<br>比如下面这个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>{</div><div class="line">  <span class="annotation">@Inject</span> Bus bus;</div><div class="line"></div><div class="line">  <span class="annotation">@Override</span></div><div class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResume</span>() {</div><div class="line">    bus.register(<span class="keyword">this</span>);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="annotation">@Produce</span> <span class="keyword">public</span> ClickEvent <span class="title">produceClick</span>() {</div><div class="line">      <span class="comment">// TODO: React to the event somehow!</span></div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ClickEvent();</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在PRODUCERS_CACHE中就会有一条记录，它的key是MainActivity.class，value对应的map中，key是ClickEvent.class，value是produceClick Method对象。<br>SUBSCRIBERS_CACHE:<br>  MainActivity.class -》<br>      ClickEvent.class -》produceClick</p>
<p>当调用AnnotatedHandlerFinder的findAllProducers方法时，会先根据传入的对象的类型，检查是否已经被缓存到PRODUCERS_CACHE，如果没有的话，就会调用loadAnnotatedMethods，利用反射去寻找所有使用了@Produce注解的方法，并且将结果缓存到PRODUCERS_CACHE中。最后，会从PRODUCERS_CACHE中取出监听类的所有Produce方法，遍历这些方法，为一个方法构建一个EventProducer对象，并将这个EventProducer对象放到一个以事件的class作为key的map中，然后返回这个map。EventProducer类包含了Produce方法和该方法所属的对象，并且提供了调用Produce方法的功能。</p>
<p>回到Bus的Register方法，调用完findAllProducers方法之后，会遍历传入的监听类的Produce方法，并且根据Produce方法的返回值类型，来检查是否已经有对应的Subscribe存在，如果有的话，就会调用Subscribe方法，并将Producer的返回值传入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Set&lt;EventHandler&gt; handlers = handlersByType.get(type);</div><div class="line"><span class="keyword">if</span> (handlers != <span class="keyword">null</span> && !handlers.isEmpty()) {</div><div class="line">  <span class="keyword">for</span> (EventHandler handler : handlers) {</div><div class="line">    dispatchProducerResultToHandler(handler, producer);</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里需要注意的是，Bus对象两个map类型的常量，用来缓存所有事件的Producer和Subscriber。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="javadoc">/** All registered event handlers, indexed by event type. */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Class&lt;?&gt;, Set&lt;EventHandler&gt;&gt; handlersByType =</div><div class="line">        <span class="keyword">new</span> ConcurrentHashMap&lt;Class&lt;?&gt;, Set&lt;EventHandler&gt;&gt;();</div><div class="line"></div><div class="line"><span class="javadoc">/** All registered event producers, index by event type. */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Class&lt;?&gt;, EventProducer&gt; producersByType =</div><div class="line">        <span class="keyword">new</span> ConcurrentHashMap&lt;Class&lt;?&gt;, EventProducer&gt;();</div></pre></td></tr></table></figure>

<p>从定义我们可以看出，一种事件只能有一个Producer，却可以有多个Subscriber。</p>
<p>找到了所有的producers之后，就是调用handlerFinder.findAllSubscribers(object)来寻找object中使用@Subscribe注解的方法，过程和findAllProducers类似，唯一的不同是一个事件可以有多个subscriber，因此findAllSubscribers的返回值类型是Map<class<?>, Set<eventhandler>&gt;。其中EventHandler包含了subscribe方法和订阅事件的对象的信息。</eventhandler></class<?></p>
<p>找到监听类所有的subscribe方法之后，就需要查看bus中时候有和这些subscribe方法对应的producer方法，如果有的话，就会使用调用subscribe方法。这也就是文档上说的，一旦有新的subscriber订阅了某一事件，并且该事件有对应的producer，那么subscriber方法就会被立即调用，并且传入producer方法的返回值。</p>
<h2 id="发送事件">发送事件</h2>
<p>post(Obejct event)方法用来发送事件给所有订阅者，它接收一个Object类型的参数，说明Otto的事件可以是任意类型的对象。post方法首先会获取所有event对象的父类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Set&lt;Class&lt;?&gt;&gt; dispatchTypes = flattenHierarchy(event.getClass());</div></pre></td></tr></table></figure>

<p>然后遍历这些父类，找到他们的所有订阅者，发送事件。这表明任何订阅了event对象父类的订阅者也都会收到event事件。值得注意的是Otto使用ThreadLocal类型来存放事件队列ThreadLocal<concurrentlinkedqueue<eventwithhandler>&gt; eventsToDispatch，这样极大的简化了多线程模式下的开发。</concurrentlinkedqueue<eventwithhandler></p>
<h2 id="取消订阅">取消订阅</h2>
<p>unregister方法，做的事情和register刚好想法，从缓存中清除所有和当前监听对象相关的producers和subscribers。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.jinkuyinku.com/2014/12/18/Otto源码分析/" data-id="x2vovan9jx0w0xsk" class="article-share-link">Share</a>
      
        <a href="http://blog.jinkuyinku.com/2014/12/18/Otto源码分析/#disqus_thread" class="article-comment-link">Comments</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="square-Otto使用入门" class="article article-type-square" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/12/17/Otto使用入门/" class="article-date">
  <time datetime="2014-12-17T14:51:24.000Z" itemprop="datePublished">Dec 17 2014</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/12/17/Otto使用入门/">Otto使用入门</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>android</li>
<li>square</li>
<li>Otto</li>
<li>event bus</li>
</ul>
<h2 id="介绍">介绍</h2>
<p><a href="https://github.com/square/otto" target="_blank" rel="external">Otto</a>是square公司出的一个事件库（pub/sub模式），用来简化应用程序组件之间的通讯。<br>Otto 修改自Google的Guava库，专门为Android平台进行了优化。</p>
<h2 id="使用">使用</h2>
<p>Otto本身是为Android平台专门开发的，使用的时候最好是使用单例模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Bus bus = <span class="keyword">new</span> Bus();</div></pre></td></tr></table></figure>

<p>bus对象只有作为单例共享的时候才足够高效，推荐使用依赖注入框架来注入单例对象或者采用类似的机制。</p>
<h2 id="发布事件">发布事件</h2>
<p>发布一个事件很简单，调用post方法就可以，post方法可以接受任何类型对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bus.post(<span class="keyword">new</span> AnswerAvailableEvent(<span class="number">42</span>));</div></pre></td></tr></table></figure>

<h2 id="订阅事件">订阅事件</h2>
<p>订阅只需要在方法上加上@Subscribe注解，同时在适当的地方调用register方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Subscribe</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">answerAvailable</span>(AnswerAvailableEvent event) {</div><div class="line">    <span class="comment">// TODO: React to the event somehow!</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>注意subscribe方法接收的参数类型需要和post参数的类型一致或者是post参数类型的父类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bus.register(<span class="keyword">this</span>);</div></pre></td></tr></table></figure>

<p>一旦调用了register方法，Otto就会通过反射去寻找所有带有@Subscribe或者@Produce注解的方法，并将这些方法缓存下来。只有在调用了register之后，该类里面标注了@Subscribe或者@Produce的方法才会在适当的时候被调用。另外，当不需要订阅事件的时候，可以调用unregister来取消订阅。</p>
<h2 id="生产者">生产者</h2>
<p>有时候当订阅某个事件的时候，希望能够获取当前的一个值，比如订阅位置变化事件的时候，希望能拿到当前的位置信息。Otto中@Produce正是扮演了这么一个生产者的角色。<br>@Produce也是用于方法，并且这个方法的参数必须为空，返回值是你要订阅的事件的类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Produce</span> <span class="keyword">public</span> AnswerAvailableEvent <span class="title">produceAnswer</span>() {</div><div class="line">    <span class="comment">// Assuming 'lastAnswer' exists.</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AnswerAvailableEvent(<span class="keyword">this</span>.lastAnswer);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>使用@Produce之后，也需要调用bus.register()。调用了register方法之后，所有之前订阅AnswerAvailableEvent事件的方法都会被执行一次，参数就是produceAnswer方法的返回值，之后任何新的订阅了AnswerAvailableEvent事件的方法，也都会立即调用produceAnswer方法。</p>
<h2 id="线程限制">线程限制</h2>
<p>可以指定@Subscribe和@Produce标注的回调方法所运行的线程，默认是在MainThread中执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这两个方法是等价的</span></div><div class="line">Bus bus1 = <span class="keyword">new</span> Bus();</div><div class="line">Bus bus2 = <span class="keyword">new</span> Bus(ThreadEnforcer.MAIN);</div></pre></td></tr></table></figure>

<p>如果不关心在哪个线程执行，可以使用ThreadEnforcer.ANY，甚至可以使用自己实现的ThreadEnforcer接口。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.jinkuyinku.com/2014/12/17/Otto使用入门/" data-id="g1e51yw5f6slqcbg" class="article-share-link">Share</a>
      
        <a href="http://blog.jinkuyinku.com/2014/12/17/Otto使用入门/#disqus_thread" class="article-comment-link">Comments</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-深入浅出RxJava（一：基础篇）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/12/09/深入浅出RxJava（一：基础篇）/" class="article-date">
  <time datetime="2014-12-09T15:30:56.000Z" itemprop="datePublished">Dec 9 2014</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/12/09/深入浅出RxJava（一：基础篇）/">深入浅出RxJava（一：基础篇）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://blog.danlew.net/2014/09/15/grokking-rxjava-part-1/" target="_blank" rel="external">原文链接</a></p>
<p><a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="external">RxJava</a>正在Android开发者中变的越来越流行。唯一的问题就是上手不容易，尤其是大部分人之前都是使用命令式编程语言。但是一旦你弄明白了，你就会发现RxJava真是太棒了。</p>
<p>这里仅仅是帮助你了解RxJava，整个系列共有四篇文章，希望你看完这四篇文章之后能够了解RxJava背后的思想，并且喜欢上RxJava。</p>
<h2 id="基础">基础</h2>
<p>RxJava最核心的两个东西是Observables（被观察者，事件源）和Subscribers（观察者）。Observables发出一系列事件，Subscribers处理这些事件。这里的事件可以是任何你感兴趣的东西（触摸事件，web接口调用返回的数据。。。）</p>
<p>一个Observable可以发出零个或者多个事件，知道结束或者出错。每发出一个事件，就会调用它的Subscriber的onNext方法，最后调用Subscriber.onNext()或者Subscriber.onError()结束。</p>
<p>Rxjava的看起来很想设计模式中的观察者模式，但是有一点明显不同，那就是如果一个Observerble没有任何的的Subscriber，那么这个Observable是不会发出任何事件的。</p>
<h2 id="Hello_World">Hello World</h2>
<p>创建一个Observable对象很简单，直接调用Observable.create即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">  Observable&lt;String&gt; myObservable = Observable.create(</div><div class="line">    <span class="keyword">new</span> Observable.OnSubscribe&lt;String&gt;() {</div><div class="line">        <span class="annotation">@Override</span></div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span>(Subscriber&lt;? <span class="keyword">super</span> String&gt; sub) {</div><div class="line">            sub.onNext(<span class="string">"Hello, world!"</span>);</div><div class="line">            sub.onCompleted();</div><div class="line">        }</div><div class="line">    }</div><div class="line">);</div></pre></td></tr></table></figure>

<p>这里定义的Observable对象仅仅发出一个Hello World字符串，然后就结束了。接着我们创建一个Subscriber来处理Observable对象发出的字符串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">  Subscriber&lt;String&gt; mySubscriber = <span class="keyword">new</span> Subscriber&lt;String&gt;() {</div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span>(String s) { System.out.println(s); }</div><div class="line"></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span>() { }</div><div class="line"></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span>(Throwable e) { }</div><div class="line">};</div></pre></td></tr></table></figure>

<p>这里subscriber仅仅就是打印observable发出的字符串。通过subscribe函数就可以将我们定义的myObservable对象和mySubscriber对象关联起来，这样就完成了subscriber对observable的订阅。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">myObservable.subscribe(mySubscriber);</div></pre></td></tr></table></figure>

<p>一旦mySubscriber订阅了myObservable，myObservable就是调用mySubscriber对象的onNext和onComplete方法，mySubscriber就会打印出Hello World！</p>
<h2 id="更简洁的代码">更简洁的代码</h2>
<p>是不是觉得仅仅为了打印一个hello world要写这么多代码太啰嗦？我这里主要是为了展示RxJava背后的原理而采用了这种比较啰嗦的写法，RxJava其实提供了很多便捷的函数来帮助我们减少代码。</p>
<p>首先来看看如何简化Observable对象的创建过程。RxJava内置了很多简化创建Observable对象的函数，比如Observable.just就是用来创建只发出一个事件就结束的Observable对象，上面创建Observable对象的代码可以简化为一行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Observable&lt;String&gt; myObservable = Observable.just(<span class="string">"Hello, world!"</span>);</div></pre></td></tr></table></figure>

<p>java</p>
<p>接下来看看如何简化Subscriber，上面的例子中，我们其实并不关心OnComplete和OnError，我们只需要在onNext的时候做一些处理，这时候就可以使用Action1类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Action1&lt;String&gt; onNextAction = <span class="keyword">new</span> Action1&lt;String&gt;() {</div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span>(String s) {</div><div class="line">        System.out.println(s);</div><div class="line">    }</div><div class="line">};</div></pre></td></tr></table></figure>

<p>subscribe方法有一个重载版本，接受三个Action1类型的参数，分别对应OnNext，OnComplete， OnError函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">myObservable.subscribe(onNextAction, onErrorAction, onCompleteAction);</div></pre></td></tr></table></figure>

<p>java</p>
<p>这里我们并不关心onError和onComplete，所以只需要第一个参数就可以</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">myObservable.subscribe(onNextAction);</div><div class="line"><span class="comment">// Outputs "Hello, world!"</span></div></pre></td></tr></table></figure>

<p>java</p>
<p>上面的代码最终可以写成这样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Observable.just(<span class="string">"Hello, world!"</span>)</div><div class="line">    .subscribe(<span class="keyword">new</span> Action1&lt;String&gt;() {</div><div class="line">        <span class="annotation">@Override</span></div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span>(String s) {</div><div class="line">              System.out.println(s);</div><div class="line">        }</div><div class="line">    });</div></pre></td></tr></table></figure>

<p>使用java8的lambda可以使代码更简洁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Observable.just(<span class="string">"Hello, world!"</span>)</div><div class="line">    .subscribe(s -&gt; System.out.println(s));</div></pre></td></tr></table></figure>

<p>Android开发中，强烈推荐使用<a href="https://github.com/evant/gradle-retrolambda" target="_blank" rel="external">retrolambda</a>这个gradle插件，这样你就可以在你的代码中使用lambda了。</p>
<h2 id="变换">变换</h2>
<p>让我们做一些更有趣的事情吧！</p>
<p>比如我想在hello world中加上我的签名，你可能会想到去修改Observable对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Observable.just(<span class="string">"Hello, world! -Dan"</span>)</div><div class="line">    .subscribe(s -&gt; System.out.println(s));</div></pre></td></tr></table></figure>

<p>如果你能够改变Observable对象，这当然是可以的，但是如果你不能修改Observable对象呢？比如Observable对象是第三方库提供的？比如我的Observable对象被多个Subscriber订阅，但是我只想在对某个订阅者做修改呢？<br>那么在Subscriber中对事件进行修改怎么样呢？比如下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Observable.just(<span class="string">"Hello, world!"</span>)</div><div class="line">    .subscribe(s -&gt; System.out.println(s + <span class="string">" -Dan"</span>));</div></pre></td></tr></table></figure>

<p>这种方式仍然不能让人满意，因为我希望我的Subscribers越轻量越好，因为我有可能会在mainThread中运行subscriber。另外，根据响应式函数编程的概念，Subscribers更应该做的事情是“响应”，响应Observable发出的事件，而不是去修改。</p>
<p>如果我能在某些中间步骤中对“Hello World！”进行变换是不是很酷？</p>
<h2 id="操作符（Operators）">操作符（Operators）</h2>
<p>操作符就是为了解决对Observable对象的变换的问题，操作符用于在Observable和最终的Subscriber之间修改Observable发出的事件。RxJava提供了很多很有用的操作符。</p>
<p>比如map操作符，就是用来把把一个事件转换为另一个事件的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Observable.just(<span class="string">"Hello, world!"</span>)</div><div class="line">  .map(<span class="keyword">new</span> Func1&lt;String, String&gt;() {</div><div class="line">      <span class="annotation">@Override</span></div><div class="line">      <span class="keyword">public</span> String <span class="title">call</span>(String s) {</div><div class="line">          <span class="keyword">return</span> s + <span class="string">" -Dan"</span>;</div><div class="line">      }</div><div class="line">  })</div><div class="line">  .subscribe(s -&gt; System.out.println(s));</div></pre></td></tr></table></figure>

<p>使用lambda可以简化为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Observable.just(<span class="string">"Hello, world!"</span>)</div><div class="line">    .map(s -&gt; s + <span class="string">" -Dan"</span>)</div><div class="line">    .subscribe(s -&gt; System.out.println(s));</div></pre></td></tr></table></figure>

<p>是不是很酷？map()操作符就是用于变换Observable对象的，map操作符返回一个Observable对象，这样就可以实现链式调用，在一个Observable对象上多次使用map操作符，最终将最简洁的数据传递给Subscriber对象。</p>
<h2 id="map操作符进阶">map操作符进阶</h2>
<p>map操作符更有趣的一点是它不必返回Observable对象返回的类型，你可以使用map操作符返回一个发出新的数据类型的observable对象。</p>
<p>比如上面的例子中，subscriber并不关心返回的字符串，而是想要字符串的hash值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Observable.just(<span class="string">"Hello, world!"</span>)</div><div class="line">    .map(<span class="keyword">new</span> Func1&lt;String, Integer&gt;() {</div><div class="line">        <span class="annotation">@Override</span></div><div class="line">        <span class="keyword">public</span> Integer <span class="title">call</span>(String s) {</div><div class="line">            <span class="keyword">return</span> s.hashCode();</div><div class="line">        }</div><div class="line">    })</div><div class="line">    .subscribe(i -&gt; System.out.println(Integer.toString(i)));</div></pre></td></tr></table></figure>

<p>很有趣吧？我们初始的Observable返回的是字符串，最终的Subscriber收到的却是Integer，当然使用lambda可以进一步简化代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Observable.just(<span class="string">"Hello, world!"</span>)</div><div class="line">    .map(s -&gt; s.hashCode())</div><div class="line">    .subscribe(i -&gt; System.out.println(Integer.toString(i)));</div></pre></td></tr></table></figure>

<p>前面说过，Subscriber做的事情越少越好，我们再增加一个map操作符</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Observable.just(<span class="string">"Hello, world!"</span>)</div><div class="line">    .map(s -&gt; s.hashCode())</div><div class="line">    .map(i -&gt; Integer.toString(i))</div><div class="line">    .subscribe(s -&gt; System.out.println(s));</div></pre></td></tr></table></figure>

<h2 id="不服？">不服？</h2>
<p>是不是觉得我们的例子太简单，不足以说服你？你需要明白下面的两点:</p>
<p>1.Observable和Subscriber可以做任何事情<br>Observable可以是一个数据库查询，Subscriber用来显示查询结果；Observable可以是屏幕上的点击事件，Subscriber用来响应点击事件；Observable可以是一个网络请求，Subscriber用来显示请求结果。</p>
<p>2.Observable和Subscriber是独立于中间的变换过程的。<br>在Observable和Subscriber中间可以增减任何数量的map。整个系统是高度可组合的，操作数据是一个很简单的过程。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.jinkuyinku.com/2014/12/09/深入浅出RxJava（一：基础篇）/" data-id="p2wj6cgfvj9czbv5" class="article-share-link">Share</a>
      
        <a href="http://blog.jinkuyinku.com/2014/12/09/深入浅出RxJava（一：基础篇）/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RxJava/">RxJava</a></li></ul>

    </footer>
  </div>
  
</article>


  
  
</section>
        
          <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android-Studio/">Android Studio</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gradle/">Gradle</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RxJava/">RxJava</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android/">android</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dagger/">dagger</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/denpendency-injection/">denpendency injection</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/依赖注入/">依赖注入</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/教程/">教程</a><span class="tag-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 20.00px;">Android</a><a href="/tags/Android-Studio/" style="font-size: 10.00px;">Android Studio</a><a href="/tags/Gradle/" style="font-size: 10.00px;">Gradle</a><a href="/tags/RxJava/" style="font-size: 10.00px;">RxJava</a><a href="/tags/android/" style="font-size: 20.00px;">android</a><a href="/tags/dagger/" style="font-size: 20.00px;">dagger</a><a href="/tags/denpendency-injection/" style="font-size: 20.00px;">denpendency injection</a><a href="/tags/依赖注入/" style="font-size: 20.00px;">依赖注入</a><a href="/tags/教程/" style="font-size: 20.00px;">教程</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">January 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">December 2014</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/07/">July 2014</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/06/">June 2014</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2015/01/09/android-gradle-深入浅出四-自定义构建过程之配置manifest/">android-gradle-深入浅出四:自定义构建过程之配置manifest</a>
          </li>
        
          <li>
            <a href="/2015/01/05/android-gradle-深入浅出三-build-task/">android-gradle-深入浅出三:build-task</a>
          </li>
        
          <li>
            <a href="/2014/12/27/android-gradle-深入浅出（二:项目结构）/">android-gradle-深入浅出（二:项目结构）</a>
          </li>
        
          <li>
            <a href="/2014/12/23/android-gradle-深入浅出（一:简介）/">android-gradle-深入浅出（一）</a>
          </li>
        
          <li>
            <a href="/2014/12/18/Otto源码分析/">Otto源码分析</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 Bruce Lee<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    
<script>
  var disqus_shortname = 'BruceLee';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//go.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">

  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>



<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>